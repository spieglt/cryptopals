y := y xor (y >> u)
y := y xor ((y << s) and b)
y := y xor ((y << t) and c)

u = 11
s = 7
t = 15
b = 0x9D2C5680			10011101001011000101011010000000
c = 0xEFC60000			11101111110001100000000000000000


starting with			10111111011101001010010011100111	3212092647

left shift by 7			10111010010100100111001110000000
then & b				10011101001011000101011010000000
						================================
						10011000000000000101001010000000	2550157952 MASK

ONLY THEN XOR WITH STARTING

mask					10011000000000000101001010000000	^
original				10111111011101001010010011100111
						================================
						00100010010100001010000001100111	575709287

So actually, most bits are preserved. But which ones?
The bottom 7 of the mask were guaranteed to be 0, both by the left-shift and the &ing.
So guaranteed to be valid through the xor. But of the next 7 up, only 2/4/5/7 were left on by the &. The mask is b minus the left-shifted bits that are 0.

So the bottom 7 are good. And what happened to them? They were left-shifted by 7 and then &'d to make the mask, so we can recalculate the mask, and once we have that, we can xor the mask against the given to get the original!




below is wrong strategy. the important thing is that each line is a mask -> xor.

right-shifted by 11 and left-shifted by 7
starting with			10111111011000110100100010001110	3210954894

						00000000000101111110110001101001
						00001011111101100011010010000000	200684672

						10111111011000110100100010001110	original
						00001011111101100011010010000000	double-shifted
						================================
						10110100100101010111110000001110	xor'd

so bottom 7 and top 4 are guaranteed to be zeroed
then xor'd with original, so top 4 and bottom 7 will be preserved

						10110100100101010111110000001110	3029695502, then it's &'d 
						10011101001011000101011010000000	with 0x9D2C5680
						================================
						10010100000001000101010000000000	2483311616

so bits 1, 4, 5, 6, 8, 11, 13, 14, 18, 20, 22, 23, 25 are preserved, rest are discarded?
no, because we know top 4 and bottom 7 of xor'd were 0, so we know 

1-4 and 26-32 were preserved through the shifts, so we only have 1 and 4... is that enough?
with those, we can determine every first and fourth, but how about the second and third?

						00101010000000000000000000000000	then left-shift by 15,
						11101111110001100000000000000000	then and that with 0xEFC60000
						================================



pivoting. solve left shift, 
starting with			10111111011000110100100010001110	3210954894
left-shift by 7			10110001101001000100011100000000	then xor
						================================
						00001110110001110000111110001110

so bottom 7 are guaranteed to be good. what would these have been xor'd against? the chunk of 7 that is iteration # away.

